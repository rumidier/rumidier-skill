<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

 <title>[Don't C study]</title> 

<!-- metadata -->
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="20050728" />
<meta name="author" content="Eric A. Meyer" />
<meta name="company" content="Complex Spiral Consulting" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>2011/3/19 토요일</h1>
<h2>
포인터와 함수에 대한 이해
</h2>
</div>

</div>


<div class="presentation">

<div class="slide">
<h1> C언어 스터디 2팀 </h1>

<h2><b>
Call-by-Value vs Call-by-Reference
</b></h2>

<h3> 발표자: 조한영 </h3>
</div>


<div class="slide">
<h1> Call-by-Value </h1>

<ul>
<li> 값에 의한 호출 </li><br/>
void swap_value (int n1, int n2)
  <br/> {
     <ul>
      int tmp = n1; <br>
      n1 = n2; <br>
      n2 = temp; <br>
      <br>
      printf ("n1 : %d \n", n1); <br>
      printf ("n2 : %d \n", n2); <br>
    </ul>
  }
</ul>
</br>
예제 코드:
<a href="http://codepad.org/JNgKq17s">Call-By-Value Full_code</a>

</div>

<div class="slide">
<h1> Call-by-Value </h1>
<ul>

</br>
</br> n1과 n2에 저장된 값은 교환 된다.</br>
</br>

<ul class="incremental">
<li> 단, 매개변수에 저장된 값만이 변경됨.</br>
</ul>

</br>
</br> main()에 선언된 val1과 val2에 저장된 값은? </br>
</br>

<ul class="incremental">
<li> val1, val2 값은 변하지 않는다.</br>
</ul>

</ul>
<div class="handout">
[any material that should appear in print but not on the slide]
</div>
</div>

<div class="slide">
<h1> Call-By-Reference </h1>
<ul>
<li> 참조에 의한 호출 </li><br/>
void swap_ref (int *p1, int *p2)
  <br/> {
     <ul>
      int tmp = *p1; <br>
      *p1 = *p2; <br>
      *p2 = temp; <br>
      <br>
    </ul>
  }
</ul>
</br>
예제코드:
<a href="http://codepad.org/WsEsE3G5">Call-By-Referene Full_code</a>
</div>

<div class="slide">
<h1> Call-By-Reference </h1>
<ul>

</br>
</br> *p1과 *p2에 전달 값은?</br>
</br>

<ul class="incremental">
<li> val1과 val2의 주소값을 전달 받는다.</br>
</ul>

</br>
</br> main()에 선언된 val1과 val2에 저장된 값은? </br>
</br>

<ul class="incremental">
<li> val1, val2 값은 참조에 의해 변하게 된다.</br>
</ul>

</ul>
</div>

<div class="slide">
<h1> Scanf &연산자 </h1>
<ul>

</br>
</br> 변수의 이름 앞에  &amp; 연산자를 붙이는 이유는? </br>
</br>

<ul class="incremental">
<li> scanf 함수 내에서 외부에 선언된 변수에 값을 채우는 형식이기 때문</li>
</ul>

</br>
</br> 문자열에는 &amp; 연산자가 붙지 않는 이유? </br>
</br>

<ul class="incremental">
<li> 문자열의 변수명은 배열의 첫번재 주소값을 반환 하기 때문</li></br>
</ul>

</ul>
</div>

<div class="slide">
<h1> 한정자 (Type Qualifiers) const </h1>

<ul>
<li>포인터의 const 선언</li>
</br>

<ul class="incremental">
<li><b>const <code> int *ptr = &amp; num; </code>
<br><br/></br>
<code> int *</code> const <code>ptr = &amp; num; </code>
<br><br/></br>
const <code> int * </code> const <code> ptr = &amp; num; </code>
<br></br><b/> </li>
</ul>
</ul>

</div>

<div class="slide">
<h1> 한정자 (Type Qualifiers) const </h1>
<ul>

<li> 포인터의 const 선언 1</li>
</br>
<ul class="incremental">
<li><b> const <code> int *ptr = &amp;num; </code>
 <code> int </code> const <code>*ptr = &amp;num; </code></li><b/>
</ul>
<ul>
<br>
<li>포인터 선언 앞에 const가 붙어 포인터를 이용해서 값의 참조만 가능 할뿐
값의 변경을 허용하지 않는다. </li>

<br>
<li> 포인터가 가리키는 변수의 이름을 이용해서는 값의 변경이 가능하다.</li>
<li> 포인터 ptr이 가리키는 변수에 저장된 값을 변경 하지 못할뿐
가리키는 대상을 변경하는 것은 전혀 문제 되지 않는다. </li>
</ul>

</ul>
</br>
예제코드:
<a href="http://codepad.org/KBbMi0Z0">Const first_code</a>
</div>

<div class="slide">
<h1> 한정자 (Type Qualifiers) const </h1>

<ul>
<li> 포인터의 const 선언 2</li>

<ul class="incremental">
 <li><b>  <code> int *</code>const <code>ptr = &amp;num; </code><b/> </li> 
</ul>
<br>
<ul>
<li> 포인터 변수명 앞에 선언되는 const는 포인터 변수 ptr을 상수화 시키는 의미</li>
<br>
<li> 포인터 ptr이 상수화됐기 때문에 ptr이 가리키는 변수에 저장된 값을 ptr을 이용해 변경하는것은
문제가 되지 않는다.</li>
<br>
<li>포인터 변수 ptr에 저장된 값은 변경이 불가능</li>

</ul>
</ul>
</br>
예제코드:
<a href="http://codepad.org/uzfCrsRj">Const two_code</a>
</div>


</body>
</html>
